#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-

"""
Parse input text into elementary discourse segments and output them

USAGE:
discourse_segmenter [GLOBAL_OPTIONS] type [TYPE_SPECIFIC_OPTIONS] [FILEs]

@author: Wladimir Sidorenko <Uladzimir Sidarenka>

"""

##################################################################
# Imports
from __future__ import print_function
from dsegmenter.bparseg import BparSegmenter, CTree, read_trees, read_segments, \
    trees2segs
from dsegmenter.edseg import EDSSegmenter, CONLL

import argparse
import codecs
import glob
import sys
import os
import re

##################################################################
# Constants and Variables
DEFAULT_ENCODING = "utf-8"
ENCODING = DEFAULT_ENCODING
EDSEG = "edseg"
BPARSEG = "bparseg"
TEST = "test"
TRAIN = "train"
SEGMENT = "segment"
Segmenter = None

##################################################################
# Methods
def _set_train_test_args(a_parser):
    """
    Add CLI options common to train and test mode to ArgumentParser instance

    @param a_parser - ArgumentParser instance to which new arguments should
                      be added

    @return \c void
    """
    a_parser.add_argument("--bpar-sfx", help = """suffix of the names of BitPar files""", \
                              type = str, default = "")
    a_parser.add_argument("--seg-sfx", help = """suffix of the names of segmentation files""", \
                              type = str, default = "")
    a_parser.add_argument("bpar_dir", help="directory containing BitPar files", \
                              type = str)
    a_parser.add_argument("seg_dir", help="directory containing segmentation files", \
                              type = str)

def _read_files(a_files, a_encoding = DEFAULT_ENCODING, a_skip_line = ""):
    """
    Return iterator over lines of the input file

    @param a_files - files to read from
    @param a_encoding - text encoding used for input/output
    @param a_skip_line - line which should be skipped during iteration

    @return iterator over input lines
    """
    if not a_files:
        for line in sys.stdin:
            line = line.decode(a_encoding)
            if line == a_skip_line:
                print(line.encode(a_encoding))
            else:
                yield line.rstrip()
    else:
        for fname in a_files:
            print("_read_files: fname =", repr(fname), file = sys.stderr)
            with codecs.open(fname, encoding = a_encoding, errors = "replace") as ifile:
                for line in ifile:
                    if line == a_skip_line:
                        print(line.encode(a_encoding))
                    else:
                        yield line.rstrip()

def _align_files(a_bpar_dir, a_seg_dir, a_bpar_sfx, a_seg_sfx):
    """
    Align BitPar and segment files in two directories

    @param a_bpar_dir - directory containing files with BitPar trees
    @param a_seg_dir - directory containing files with discourse segments
    @param a_bpar_sfx - suffix of the names of BitPar files
    @param a_seg_sfx - suffix of the names of segmentation files

    @return iterator over list of 2-tuples with BitPar and segment file
    """
    segf = ""; basefname = "";
    BP_SFX_RE = re.compile(re.escape(a_bpar_sfx))
    bpar_files = glob.iglob(os.path.join(a_bpar_dir, '*' + a_bpar_sfx))
    for bpf in bpar_files:
        basefname = BP_SFX_RE.sub("", os.path.basename(bpf))
        segf = os.path.join(a_seg_dir, basefname + a_seg_sfx)
        if os.path.isfile(segf) and os.access(segf, os.R_OK):
            yield (bpf, segf)
        else:
            print(\
                "WARNING: No counterpart file found for BitPar file '{:s}'.".format(bpf), \
                    file = sys.stderr)

def _read_trees_segments(a_bpar_dir, a_seg_dir, a_bpar_sfx, a_seg_sfx, \
                             a_encoding = DEFAULT_ENCODING):
    """
    Read input files containing discourse segments and BitPar trees

    @param a_bpar_dir - directory containing files with BitPar trees
    @param a_seg_dir - directory containing files with discourse segments
    @param a_bpar_sfx - suffix of the names of BitPar files
    @param a_seg_sfx - suffix of the names of segmentation files
    @param a_encoding - text encoding used for input/output

    @return 2-tuple with a list of segments and a list of trees
    """
    trees = []; segments = []
    tree2seg = {}; toks2trees = {}; toks2segs = {};
    bpar_seg_files = _align_files(a_bpar_dir, a_seg_dir, a_bpar_sfx, a_seg_sfx)
    # do tree/segment alignment
    for bpf, segf in bpar_seg_files:
        with codecs.open(bpf, 'r', encoding = a_encoding) as ibpf:
            toks2trees, _ = read_trees(ibpf)
        with codecs.open(segf, 'r', encoding = a_encoding) as isegf:
            toks2segs = read_segments(isegf)
        tree2seg = trees2segs(toks2trees, toks2segs)
        for t, s in tree2seg.iteritems():
            trees.append(t)
            segments.append(s)
    return (trees, segments)

def _output_segment_forrest(a_forrest, a_segmenter, a_output, a_encoding):
    """
    Split CONLL sentences in elementary discourse units and output them

    @param a_forrest - pointer to CONLL forrest
    @param a_segmnter - pointer to discourse segmenter
    @param a_output - boolean flag indicating whether dependency trees
    should be printed
    @param a_encoding - text encoding used for output

    @return \c void
    """
    if a_forrest.is_empty():
        return
    else:
        if a_output:
            print(unicode(a_forrest).encode(a_encoding))
        sds_list = [a_segmenter.segment(sent) for sent in a_forrest]
        for sds in sds_list:
            sds.pretty_print(a_encoding = a_encoding)
        a_forrest.clear()

def edseg_segment(a_ilines, a_output_trees, a_encoding = DEFAULT_ENCODING):
    """
    Perform rule-based segmentation of CONLL dependency trees

    @param a_ilines - iterator over input lines
    @param a_output_trees - boolean flag indicating whether dependency trees
    should be printed
    @param a_encoding - text encoding used for input/output

    @return \c void
    """
    forrest = CONLL()
    segmenter = EDSSegmenter()
    for line in a_ilines:
        if not line:
            # print collected sentences
            _output_segment_forrest(forrest, segmenter, a_output_trees, a_encoding)
            # output line
            print(line.encode(a_encoding))
        # otherwise, append the line to the CONLL forrest
        else:
            forrest.add_line(line)
            istart = True
    # output remained EDUs
    _output_segment_forrest(forrest, segmenter, a_output_trees, a_encoding)

def bparseg_segment(a_segmenter, a_ilines, a_encoding = DEFAULT_ENCODING):
    """
    Perform machine-learning driven segmentation of BitPar constituency trees

    @param a_segmenter - pointer to BitPar segmenter
    @param a_ilines - iterator over input lines
    @param a_encoding - text encoding used for input/output

    @return \c void
    """
    segments = []
    for ctree in CTree.parse_lines(a_ilines):
        segments = a_segmenter.segment([ctree])
        print(u'\n'.join([unicode(s[-1]) for s in segments]).encode(a_encoding))

def bparseg_test(a_segmenter, a_trees, a_segments):
    """
    Evaluate performance of segment classification

    @param a_segmenter - pointer to BitPar segmenter
    @param a_trees - list of BitPar trees
    @param a_segments - list of discourse segments corresponding to BitPar trees

    @return \c void
    """
    macro_f1, micro_f1 = a_segmenter.test(a_trees, a_segments)
    print("Macro F1-score: {:.2%}".format(macro_f1), file = sys.stderr)
    print("Micro F1-score: {:.2%}".format(micro_f1), file = sys.stderr)

def bparseg_train(a_segmenter, a_trees, a_segments, a_path):
    """
    Evaluate performance of segment classification

    @param a_segmenter - pointer to BitPar segmenter
    @param a_trees - list of BitPar constituency trees
    @param a_segments - list of discourse segments corresponding to trees
    @param a_path - path in which to store the model

    @return \c void
    """
    a_segmenter.train(a_trees, a_segments, a_path)

def main(argv):
    """
    Read input text and segment it into elementary discourse units.

    @param argv - command line arguments

    @return \c 0 on success, non-\c 0 otherwise
    """
    # process arguments
    parser = argparse.ArgumentParser(description = """Script for segmenting text
into elementary discourse units.""")

    # define global options
    parser.add_argument("-e", "--encoding", help = "input encoding of text", nargs = 1, \
                            type = str, default = DEFAULT_ENCODING)
    parser.add_argument("-s", "--skip-line", help = """lines which should be ignored during the
processing and output without changes (defaults to empty lines)""", type = str, default = "")

    # add type-specific subparsers
    subparsers = parser.add_subparsers(help="type of discourse segmenter to use", dest = "dtype")

    # edgseg argument parser
    parser_edseg = subparsers.add_parser(EDSEG, help = "rule-based discourse segmenter for CONLL\
 dependency trees")
    parser_edseg.add_argument("-o", "--output-trees", help="output dependency trees along with\
 segments", action = "store_true")
    parser_edseg.add_argument("files", help="input files", nargs = '*', metavar="file")

    # bpar argument parser
    parser_bpar = subparsers.add_parser(BPARSEG, help = """machine-learning driven discourse\
 segmenter for BitPar constituency trees""")
    bpar_subparsers = parser_bpar.add_subparsers(help = "action to perform", dest = "mode")
    parser_bpar_train = bpar_subparsers.add_parser(TRAIN, help = """train new model on BitPar
 and segment files""")
    parser_bpar_train.add_argument("--cross-validate", help = "train model in cross-validation mode")
    parser_bpar_train.add_argument("model", help = "path to file in which to store the trained model", \
                                       type = str)
    _set_train_test_args(parser_bpar_train)

    parser_bpar_test = bpar_subparsers.add_parser(TEST, help = """test model on BitPar
 and segment files""")
    parser_bpar_test.add_argument("-m", "--model", help = "path to file containing model", \
                                         type = str, default = BparSegmenter.DEFAULT_MODEL)
    _set_train_test_args(parser_bpar_test)

    parser_bpar_segment = bpar_subparsers.add_parser(SEGMENT, help = """split BitPar trees\
 into discourse units""")
    parser_bpar_segment.add_argument("-m", "--model", help = "path to file containing model", \
                                         type = str, default = BparSegmenter.DEFAULT_MODEL)
    parser_bpar_segment.add_argument("files", help="input files", nargs = '*', metavar="file")

    args = parser.parse_args()

    # process input files
    ifiles = []
    if hasattr(args, "files"):
        ifiles = _read_files(args.files, args.encoding, args.skip_line)

    # process input with edseg
    if args.dtype == EDSEG:
        edseg_segment(ifiles, args.output_trees)
    # process input with bparseg
    else:
        if args.mode == TRAIN:
            mdir = os.path.dirname(args.model)
            if mdir == '':
                pass
            elif os.path.exists(mdir):
                if not os.path.isdir(mdir) or not os.access(mdir, os.R_OK):
                    puts >> sys.stderr, "Can't write to directory '{:s}'.".format(mdir)
            else:
                os.makedirs(mdir)
            segmenter = BparSegmenter()
            trees, segments = _read_trees_segments(args.bpar_dir, args.seg_dir, args.bpar_sfx, \
                                                       args.seg_sfx, args.encoding)
            bparseg_train(segmenter, trees, segments, args.model)
        else:
            assert os.path.exists(args.model) and os.path.isfile(args.model) and \
                os.access(args.model, os.R_OK), "Can't read model file '{:s}'.".format(args.model)
            segmenter = BparSegmenter(a_model = args.model)
            if args.mode == TEST:
                trees, segments = _read_trees_segments(args.bpar_dir, args.seg_dir, args.bpar_sfx, \
                                                           args.seg_sfx, args.encoding)
                bparseg_test(segmenter, trees, segments)
            else:
                bparseg_segment(segmenter, ifiles, args.encoding)

##################################################################
# Main
if __name__ == "__main__":
    main(sys.argv[1:])
